from collections import defaultdict
import pandas as pd

# TASK
# Task: Analyze the value each ad network brings to the overall business and provide recommendations.
# Our primary goal is to achieve a 35% blended ROAS D30. Explain your approach in detail and include calculations.

blended_revenue_d30 = {
    "Month1":50000,
    "Month2":55000,
    "Month3":80000,
    "Month4":90000,
}

spend = {
    # spend for each month per network
    "Organic":[0,0,0,0],
    "NetworkA":[100000,150000,150000,150000],
    "NetworkB":[0,0,100000,100000],
    "NetworkC":[0,0,0,200000]
}

installs = {
    # installs for each month per network
    "Organic":[1000,1450,1500,800],
    "NetworkA":[2500,3500,3500,3000],
    "NetworkB":[0,0,1500,1500],
    "NetworkC":[0,0,0,6000]
}

class NetworkAnalysis:
    def __init__(self,installs, spend, blended_revenue_d30):
        self.installs = installs
        self.spend = spend
        self.blended_revenue_d30 = blended_revenue_d30 
        self.CPA = defaultdict(float)
        self.ARPU = defaultdict(float)

    def estimate_cpa(self) -> defaultdict:
        # CPA per Month per Network
        
        cpa_data = defaultdict(list)

        for network, marketing_budget in self.spend.items():
            if network == "Organic":
                continue
            for i, (mb, nu) in enumerate(zip(marketing_budget, installs[network])):
                if nu > 0:
                    monthly_cpa = mb / nu
                else:
                    monthly_cpa = 0
                cpa_data[f"Month{i+1}"].append(round(monthly_cpa, 2))
            
            self.CPA[network] = round(sum(marketing_budget) / sum(installs[network]),2)

        monthly_cpa_df = pd.DataFrame(cpa_data, index=[network for network in spend.keys() if network != "Organic"])
        CPA_df = pd.DataFrame(self.CPA.items(),columns = ["Network","CPA"])

        print("\nMonthly CPA DataFrame:")
        print(monthly_cpa_df)
        print("\nOverall CPA DataFrame:")
        print(CPA_df)
        return self.CPA

    def estimate_revenue(self) -> defaultdict:
        # ARPU per Network
        # We assume that the revenue generated by each network is the % of installs / total install * blended revenue 
        total_installs_per_month = [sum(x) for x in zip(*self.installs.values())]
        revenue_data = defaultdict(list)
        installs_data = defaultdict(list)

        for network, new_users in self.installs.items():
            total_revenue = 0
            total_installs = 0
            for i, nu in enumerate(new_users):
                if nu > 0:
                    revenue = (nu / total_installs_per_month[i]) * self.blended_revenue_d30[f"Month{i+1}"]
                else:
                    revenue = 0
                total_revenue += revenue
                total_installs += nu

                revenue_data[f"Month{i+1}"].append(round(revenue,2))
                installs_data[f"Month{i+1}"].append(nu)


            self.ARPU[network] = round(total_revenue / total_installs, 2)

        revenue_df = pd.DataFrame(revenue_data, index=installs.keys())
        installs_df = pd.DataFrame(installs_data, index=installs.keys())

        print("\nMonthly Revenue DataFrame:")
        print(revenue_df)
        print("\nInstalls DataFrame:")
        print(installs_df)

        print("\nARPU DataFrame:")
        ARPU_df = pd.DataFrame(self.ARPU.items(), columns=['Network', 'ARPU'])
        print(ARPU_df)
        print()
        return self.ARPU

# We use Month 4 where all networks were active for estimating the ROAS 
# 
# lower and upper bound of the users that can be acquired:
# - for the lower bound we say that each network should at least have 100 new users
# - for the upper bound (ie max number of new users that can be acquired) is estimated as the total 
#      marketing budget of the month / min(CPA) from the three networks 

def simulate_campaign_results(lower_bound,upper_bound,step,target_budget,target_revenue,ARPU,CPA):
    results = []
    
    for new_users_A in range(lower_bound,upper_bound,step):
        for new_users_B in range(lower_bound,upper_bound,step):
            
            if new_users_A + new_users_B > upper_bound:
                break

            for new_users_C in range(lower_bound,upper_bound,step):

                if new_users_A + new_users_B + new_users_C > upper_bound:
                    break

                new_users_revenue = (new_users_A * ARPU['NetworkA']) +\
                                    (new_users_B * ARPU['NetworkB']) +\
                                    (new_users_C * ARPU['NetworkC']) +\
                                    (installs['Organic'][-1] * ARPU['Organic'])

                budget_spent =  (new_users_A*CPA['NetworkA']) +\
                                (new_users_B*CPA['NetworkB']) +\
                                (new_users_C*CPA['NetworkC'])

                if new_users_revenue >= target_revenue and budget_spent <= target_budget:
                    results.append((new_users_revenue,
                                    (new_users_A,new_users_B,new_users_C),
                                    budget_spent))
    
    return results 

NA = NetworkAnalysis(installs,spend,blended_revenue_d30)
CPA = NA.estimate_cpa()
ARPU = NA.estimate_revenue()

# SIMULATION PROCESS FOR DETERMINING THE MAX ROAS ON MONTH 4
TARGET_PERCENTAGE = 0.35
marketing_budget_month_4 = sum(budget[-1] for budget in spend.values())
lower_bound,upper_bound = 0,int(marketing_budget_month_4 / min(CPA.values()))
target_revenue = marketing_budget_month_4 * TARGET_PERCENTAGE
step = 100


results = simulate_campaign_results(lower_bound = lower_bound,
                                    upper_bound = upper_bound,
                                    step = step,
                                    target_budget = marketing_budget_month_4,
                                    target_revenue = target_revenue,
                                    ARPU = ARPU,
                                    CPA = CPA
                                )

if not results:
    print(f"A blended {int(TARGET_PERCENTAGE*100)}% D30 ROAS cannot be achived! \n")
    TARGET_PERCENTAGE = int(TARGET_PERCENTAGE*100)
    
    # search for the ROAS that can be achieved 
    for i in reversed(range(TARGET_PERCENTAGE)):
        target_revenue = marketing_budget_month_4 * (i/100)

        results = simulate_campaign_results(lower_bound = lower_bound,
                                    upper_bound = upper_bound,
                                    step = step,
                                    target_budget = marketing_budget_month_4,
                                    target_revenue = target_revenue,
                                    ARPU = ARPU,
                                    CPA = CPA
                                )
        if results:
            results = sorted(results,key=lambda x:x[0],reverse=True)
            ROAS = round(results[0][0],2)
            optimal_allocation = [round(x/sum(results[0][1]),2) for x in results[0][1]] 

            print(f"For achieving {i}% blended ROAS D30 on Month 4 we allocate:")
            print(f"{optimal_allocation[0]*100}% of the marketing budget to Network A")
            print(f"{optimal_allocation[1]*100}% of the marketing budget to Network B")
            print(f"{optimal_allocation[2]*100}% of the marketing budget to Network C \n")
            print(f"This allocation results to ${ROAS} blended ROAS D30")
            break
        else:
            print(f"A blended {i}% D30 ROAS cannot be achived! \n")
    
else:
    results = sorted(results,key=lambda x:x[0],reverse=True)
    ROAS = round(results[0][0],2)
    optimal_allocation = [round(x/sum(results[0][1]),2) for x in results[0][1]] 

    print(f"For achieving {TARGET_PERCENTAGE*100}% blended ROAS D30 on Month 4 we allocate:")
    print(f"{optimal_allocation[0]*100}% of the marketing budget to Network A")
    print(f"{optimal_allocation[1]*100}% of the marketing budget to Network B")
    print(f"{optimal_allocation[2]*100}% of the marketing budget to Network C \n")
    print(f"This allocation results to ${ROAS} blended ROAS D30")
